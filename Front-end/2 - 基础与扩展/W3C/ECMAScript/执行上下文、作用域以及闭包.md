

## 一、 执行上下文
js引擎在执行每个代码段（全局代码、函数体）前，浏览器已经做了一些“准备工作”（预编译）：

**全局代码**

1. 变量、函数表达式 —— 仅声明不赋值（默认赋值undefined）
2. this —— 赋值
3. 函数声明 —— 赋值
   
**函数体**

4. 参数 —— 赋值
5. arguments —— 赋值
6. 自由变量的取值作用域 —— 赋值 （注：自由变量的取值是在函数定义时而非函数执行时确定的）

经过以上“准备工作”就生成了执行上下文（执行上下文环境），所以可以给执行上下文下个定义：

> 执行代码段之前，对所有变量或函数声明进行赋值（有些默认赋值undefined），所形成的环境就是执行上下文环境。

上述两种代码段分别形成了**全局执行上下文**和**函数块执行上下文**，当函数调用完成时，对应的执行上下文及其中的变量就会被销毁，再重新回到全局执行上下文环境，处于活动状态的执行上下文只有一个。而这种压栈出栈形成的数据栈就是**执行上下文栈**。


## 二、 作用域
JS作用域分为：全局作用域、函数作用域、块作用域(ES6)。   
函数作用域在函数定义时就确定了，而不是函数调用时。    
作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。    

**自由变量：** 在 B 作用域中使用了变量 x，却未在 B 作用域中定义，那么 x 就称为 B 作用域的自由变量。   
自由变量 x 应该到创建 B 作用域的那个作用域（假设为 A 作用域）中取值。若 A 作用域中也未定义变量 x，则继续到创建 A 作用的那个作用域中寻找，直至寻找到全局作用域，这就是**作用域链**。 

总结：
1. 作用域是一个区域，用于隔离变量的有效范围。它是在定义时确定的，与是否调用无关。
2. 执行上下文是预编译后，由所有变量和函数所组成的变量环境。它是在调用时确定的，不同的调用会产生不同的执行上下文。
3. 沿着定义时形成的作用域包含关系，向上寻找自由变量取值的方式，就是作用域链。

## 三、 闭包
由于作用域链的存在，我们很容易理解下边的代码：

    // 全局作用域 A
    var a = 6;
    function fn() {
      // 函数作用域 B
      var b = 8;
      console.log(a + b);
    }
    fn();   // 14

因为作用域 B 中的 a 是自由变量，所以要到定义 B 的 A 中寻找 a 的取值，即在正常作用域链中，函数内部可以取到函数外部的变量值，反之则不行。   
那么，有没有办法让函数外部取到函数内部的变量呢？ —— 这就是闭包所要实现的功能    

闭包有两种情况：函数作为返回值，函数作为传参。
**函数作为返回值**

    // 全局作用域 A
    function fn() {
        // 函数作用域 B
        var a = 6;
        return function getA() {
            // 函数作用域 C
            console.log(a)
        }
    }
    var f1 = fn()
    f1()    // 6

**函数作为传参**
 
    var a = 6,
        getA = function() {
            // 函数作用域 B
            console.log(a)
        }
    (function fn(f) {
        // 函数作用域 A
        var a = 8
        f()   // 6
    })(getA)

要讲清楚闭包实现的原理，就要结合作用域和执行上下文来理解。以第一种情况为例：

1. 作用域是在定义时形成的，自由变量会沿作用域链寻找取值。   
定义时形成了作用域 A、B、C，且 a 是 C 中的自由变量，所以 a 可以沿着作用域链找到 6。

2. 执行上下文是在调用时的预编译形成的，执行结束后就会销毁。   
当代码开始执行时，全局执行上下文入栈，处于活动状态；
当执行 var f1 = fn() 时，