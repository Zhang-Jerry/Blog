1. `document.querySelector('#app')`与`document.getElementById('app')`有什么区别？
    
        <ul>
            <li>111</li>
            <li>222</li>
            <li>333</li>
        </ul>

        //`document.querySelector('#app')`选出的元素是静态的：
        <script>
            var ul = document.querySelector('ul');
            var list = ul.querySelectorAll('li');
            //又创建了5个新的li，添加在ul列表上。
            for (var i = 0; i < 5; i++) {
                ul.appendChild(document.createElement('li'));
            }
            console.log(list.length)  // 仍然是3
        </script>

        // `document.getElementById('app')`是动态的
        <script>
            var ul = document.getElementsByTagName('ul')[0];
            var list = ul.getElementsByTagName('li');
            //又创建了5个新的li，添加在ul列表上。
            for (var i = 0; i < 5; i++) {
                ul.appendChild(document.createElement('li'));
            }
            console.log(list.length)  // 变成了8
        </script>

    同理可推广到：`document.querySelectorAll`、`document.getElementsByClassName`、`document.getElementsByTagName`

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

2. `dom`对象与`jQuery`对象互转

        var pDom = document.querySelectorAll('p')
        var $pDom = $('p')
        
        // dom 转 jQuery
        var $pDom1 = $(pDom)

        // jQuery 转 dom，分两种情况
        // 情况一：jQuery 对象只含有一个元素，例如 $('#p')
        var pDom1 = $pDom[0]      // 方法1
        var pDom2 = $pDom.get(0)  // 方法2
        // 情况二：jQuery 对象含有多个元素，例如 $('p')
        var pDom1 = []
        var len = $pDom.length
        for(var i = 0; i < len; i++) {
            pDom1.push($pDom[i])
        }

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

3. 实现动画效果

        // CSS
        .box {
            position: relative; // relative、absolute、fixed之一
            animation: mymove 5s infinite;
        }
        @keyframes {
            from {
                left: 0;
            }
            to {
                left: 200px;
            }
        }

        // js —— 定时器
        let box = document.querySelector('.box')
        let flag = true
        let left = 0
        setInterval(() => {
            left === 0 ? flag = true : (left === 100 ? flag = false : '')
            flag ? box.style.left = `${left++}px` : box.style.left = `${left--}px`
        }, 1000 / 60)

        // js —— requestAnimationFrame
        let box = document.getElementById(".box");
        let flag = true;
        let left = 0;
        function render() {
            left == 0 ? flag = true : left == 100 ? flag = false : '';
            flag ? box.style.left = ` ${left++}px` : box.style.left = ` ${left--}px`;
        }
        let requestAnimFrame = (function(){     //兼容性处理
            return  window.requestAnimationFrame       ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame    ||
                    function(callback){
                        window.setTimeout(callback, 1000 / 60);
                    };
        })();
        (function animloop() {
            render();
            requestAnimFrame(animloop);
        })();

    两种js实现方案对比：        
    渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是DOM视图更新的最小间隔。由于主流的屏幕刷新率都在60hz，因此渲染一帧的时间就必须控制在16.7ms内才能保证不掉帧。也就是说每一次渲染都要在 16.7ms 内页面才够流畅不会有卡顿感。这段时间内浏览器需要完成如下事情：

    * js执行：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等
    * 样式计算
    * 重排和重绘

    一个帧内要做这么多事情，如果js执行时间过长超过16.7ms，就会丢掉一次帧的绘制，出现卡顿现象。一般一个帧内的多次DOM改动会被合并渲染。

    window.requestAnimationFrame用于在下一个渲染帧之前执行一个回调函数。可以用来做逐帧动画，这会使你的动画函数先于浏览器重绘动作。通常来说，被调用的频率就是60hz。

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

4. 实现一个“沉睡”函数

        function sleep(time) {
            return new Promise((resolve) => {
                setTimeout(resolve, time)
            })
        }

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

5. 数组去重

        // 方法一：Set
        [...new Set([1,1,3,4,2,2])]  或 Array.from(new Set([1,1,3,4,2,2]))

        // 方法二：filter 
        // 唯一元素的特点：该元素在数组中的索引，与该元素第一次出现时的索引值相同。eg. ['a','b','a'] b的索引是1，b第一次出现时的索引也是1，所以b唯一；但第二个a的索引是2，它第一次出现时的索引却是0，所以a不唯一。
        function unique(arr) {
            return arr.filter((item, index, arr) => {
                return arr.indexOf(item) === index
            })
        }

        // 方法三：双循环
        function unique(arr) {
            let res = [arr[0]]
            for (let i = 1; i < arr.length; i++) {
                let flag = true
                for (let j = 0; j < res.length; j++) {
                    if (arr[i] === res[j]) {
                        flag = false
                        break
                    }
                }
                if (flag) {
                    res.push(arr[i])
                }
            }
            return res
        }

        // 方法四：对象属性
        function unique(arr) {
            let res = []
            let obj = {}
            for (let i = 0; i < arr.length; i++) {
                if (!obj[arr[i]]) {
                    res.push(arr[i])
                    obj[arr[i]] = 1
                } else {
                    obj[arr[i]] += 1
                }
            }
            return res
        }

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

6. 数组扁平化
   
        // 方法一：递归
        // 普通递归
        function flatten(array) {
            let result = []
            array.forEach((item, i) => {
                if (array.isArray(item)) {
                    result = result.concat(flatten(item))
                } else {
                    result.push(item)
                }
            })
        }

        // reduce递归
        function flatten(array) {
            return array.reduce((resultArray, currentValue) => {
                currentValue = Array.isArray(currentValue) ? flatten(currentValue) : currentValue
                resultArray.concat(currentValue)
            }, [])
        }

        // 方法二：解构运算符 + concat ...   
        // 利用...可以将最外层数组转为逗号分隔的参数序列
        // 利用concat可以实现将多个参数拼接到数组上 [1,2].concat(3, 4) -> [1,2,3,4]
        function flatten(array) {
            while (array.some(item => Array.isArray(item))) {
                array = [].concat(...array)
            }
            return array
        }

        // 方法三：toString()  利用其能将数组变成以逗号分隔的字符串特性 [1, [2, [3, [4, 5]]]].toString() -> '1,2,3,4,5'  缺点：仅适用纯数字组成的数组
        function flatten(array) {
            let str = array.toString()          // '1,2,3,4,5'
            let strArray = str.split(',')       // ['1', '2', '3', '4', '5']
            array = array.map(item => +item)    // 隐式类型转换，字符串 -> 数字
            return array
        }

        let ar = flatten([1,2,[3,4,[5,6]]])
        console.log(ar)

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

7. 如何避免重定向？


/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

8. 类型检查

    js 数据类型：       

    * 基本类型：Number、String、Boolean、Undefined、Null、Symbol      
    * 引用类型：Object（Object、Function、Array、Date、RegExp）

    typeof判断数据类型：（返回number、string、boolean、undefined、symbol、object）    

    * 对于基本类型，除null外，均可返回正确的结果；
    * 对于引用类型，除function外，均返回Object；
    * 对于null，返回Object；
    * 对于function，返回Function。

    instanceof

    constructor

    toString() 是 Object 的原型方法，调用该方法，默认返回当前数据类型的 [[Class]]，格式为[object Xxx]。不仅适用于Object，基本类型也适用。

        function getType(data) {

        }

        
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */