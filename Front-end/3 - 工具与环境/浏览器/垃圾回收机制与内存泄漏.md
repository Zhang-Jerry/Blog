
V8 采用的垃圾回收算法 —— 分代回收(Generation GC)

https://juejin.im/post/6844903695721709581#heading-15

https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/

## 一. 什么是垃圾

确定不会再被使用的数据，即为垃圾数据。

栈(stack)会自动分配内存空间，会自动释放空间。无需垃圾回收。
堆(heap)动态分配的内存，大小不定也不会自动释放。需要垃圾回收机制来释放内存空间。
**注**：闭包中的变量并不保存在栈内存中，而是保存在堆内存中。这也是闭包能引用到函数内变量的原因。

## 二、算法分类

常见的算法有两类：**标记清除**、**引用计数**

V8 的垃圾回收机制：

分代回收机制：

  1. 将内存对象分为“新生代”和“老生代”，新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

  2. “新生代”被等分为“from”和“to”两个空间，新创建的对象会放入from，当from空间不足时，会执行Scavenge算法进行垃圾回收：
    1. 检查from中的对象，如果是非活跃对象，则直接执行 2； 如果是活跃对象，则继续判断是否符合老生代条件(已经经历过Scavenge算法)，若符合则放入老生代中，若不符合则放入to中
    2. 如果是非活跃对象，则释放对象空间
    3. 最后，将from与to交换
  
  3. “老生代”中使用**标记清除**算法进行垃圾回收

## 三、 标记清除如何回收垃圾

### 1. 标记

V8 采用 **可达性** 算法来判断堆中对象应不应该被回收，判断步骤如下：

* 从根节点出发，遍历所有的对象
* 可以遍历到的对象，标识为可达(reachable)
* 无法遍历到的对象，标识为不可达(unreachable)

浏览器环境下，根节点包括：

* 全局对象 window，位于每个 iframe 中
* 文档 DOM 对象
* 存放在栈中的变量

根节点不是垃圾，不能被回收。

### 2. 清理

标记完成后，统一清理被标识为不可达的对象。

### 3. 内存整理

清理操作后，堆内存中存在大量不连续的空间，称为 **内存碎片**