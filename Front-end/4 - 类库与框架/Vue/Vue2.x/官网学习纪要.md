# Vue 官网学习纪要
> 整理记录之前学习中疏忽、遗漏、不理解的知识点，对其进行排查和深究，以期更好的掌握Vue基础知识。


# 基础
***
## 1.
> **Vue不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。**

具体是什么特性？
**Object.defineProperty()**
> 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

深入理解：详见[Object.defineProperty与双向数据绑定](./Object.defineProperty与双向数据绑定.md)

***
## 2.
什么是**CDN**？
IDC、云计算、CDN之间什么关系？

**理解**：CDN全称Content Delivery Network，即内容分发网络，指通过互联网与各种缓存服务器（基于IDC）相连的网络系统。CDN是用来给网站加速的。用户请求CDN资源时，利用全局负载技术，将访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。
IDC全称Internet Data Center，即互联网数据中心，简称IDC机房。是云计算和CDN的基础，是整个互联网世界的大后方。
云计算可以理解为通过一些计算方式，将共享的软、硬件资源和信息，整个一起，形成一个大型虚拟资源池，资源取用更加便捷、灵活，有效提升了资源再分配的效率和规模，以及平台运作的效率。所以，云计算是以IDC为依托的上层建筑。

查阅可知，目前主流的云服务提供商(阿里云、七牛云、腾讯云等)也是主流的CDN服务商，因为这两项服务都基于硬件——IDC的存在，而这些IDC大概率都是这些服务商搭建的。

***
## 3.
> 运行时 + 编译器 vs. 只包含运行时

什么是 **运行时**、**编译器**？两种版本什么区别？

> **编译器**：用来将模板字符串编译成为 JavaScript 渲染函数的代码。
> **运行时**：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。

> 如果你需要在客户端编译模板 (比如传入一个字符串给 `template` 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版：

    // 需要编译器
    new Vue({
        template: '<div>{{ hi }}</div>'   // 模板字符串
    })

    // 不需要编译器
    new Vue({
        render (h) {
            return h('div', this.hi)    // js渲染函数
        }
    })

当使用预处理器 `vue-loader` 时(通常配置在webpack配置项中)，.vue文件内的模板会在构建(npm run build)时预编译成js渲染函数。因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本。

***
## 4.
**安装淘宝镜像：**

    npm install -g cnpm --registry=https://registry.npm.taobao.org

***
## 5.
> 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，...

何为**渐进式框架**？何为**自底向上逐层应用**？

理解：渐进式简单来说，你使用Vue，可以只使用它的核心功能甚至其中几个指令实现视图渲染，也可以深入使用它的双向绑定、单文件组件，或者进一步用它来做单页面应用，并引入路由vue-router、状态管理vuex等等。也就是说，可以用Vue实现简单需求，也可以用Vue配合其它技术实现更复杂需求，甚至服务端渲染。而自底向上可以认为是由基础到复杂，由局部化到系统化构建项目的过程。

***
## 6.
> **Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统**

何为**声明式渲染**？
[怎么理解“声明式渲染”](https://www.zhihu.com/question/68121329)
`声明式渲染`是与`命令式渲染`相对应的概念。
既然都是“渲染”，自然与浏览器中dom的渲染机制有关。[详见“浏览器渲染原理”]()
**命令式渲染：**需要通过操作dom，控制dom按照业务逻辑一步步完成重新渲染过程。
**声明式渲染：**无需操作dom，只需将声明好的变量嵌入dom中，通过控制变量值的改变实现重新渲染。

***
## 7.
> **所有的Vue组件都是Vue实例，并且接受相同的选项对象(一些根实例特有的选项除外)**

**vue-cli单间的SPA中只有一个new，如何理解每个组件都是实例？**

SPA中唯一的new是根实例，而通过import使用的.vue组件，其实例化过程交给了vue-loader来完成，它们本质上都是实例。

***
## 8.
**如何理解Vue遵循MVVM模型？**

![MVVM.png](https://i.loli.net/2019/06/17/5d07951e1bef976565.png)

***
## 9.
> **当一个 Vue 实例被创建时，它将 data 对象中的所有的属性加入到 Vue 的响应式系统中**

* **实例创建时：** 只有实例化时data中的属性才是响应式的，实例化之后向实例对象添加的属性，不具有响应式。
* **响应式系统：** 属性值改变时，Vue将通知视图更新数据。

使用时，自定义属性与Vue自带的实例属性、方法的区别是，自带的都有前缀$

***
## 10.
> **不要在选项属性或回调上使用箭头函数，比如 created: () => console.log(this.a) 或 vm.$watch('a', newValue => this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止**

原因：因为箭头函数是和父级上下文绑定在一起的，this不会是Vue实例。   
注意：created() {} 是ES6函数声明的简写形式，不是箭头函数。

***
## 11.
> **生命周期**

![lifecycle.png](https://i.loli.net/2019/06/19/5d0a229af2e1156221.png)

***
## 12.
> 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。

意思是vue模版中，可以使用表达式，例如：`{{number + 1}}`或`<p :"number + 1"></p>`，其中number是实例中定义的数据。当需要使用全局变量时，只能使用JS语言默认的全局变量，例如Math、Date等，而不能使用自定义的全局变量，例如定义了`window.myVar = 11`，不能在模版表达式中使用myVar。

***
## 13.
> 计算属性

> 计算属性是基于它们的响应式依赖进行缓存的，Date.now() 不是响应式依赖：
        
    computed: {
        now: function () {
            return Date.now()
        }
    }
原因：Date.now() 不是 响应依赖，因为它跟 Vue 的数据观察系统无关。
所以，使用计算属性时，一定要针对实例属性数据进行定义，否则计算属性将不会动态变化。

***
## 14.
> class与style绑定

    <div
        class="static"
        v-bind:class="{ active: isActive, 'text-danger': hasError }"
    ></div>
注意：对象写法可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用**引号括起来**) 来命名。

数组写法中，也可以混合对象写法使用：

`<div v-bind:class="[{ active: isActive }, errorClass]"></div>`

> 在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面，例如：

`<my-component class="baz boo"></my-component>`

HTML 将被渲染为:

`<p class="foo bar baz boo">Hi</p>`

当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。

`<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>`

这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。

***
## 15. v-if、v-show、visibility、display
v-if 切换dom时，会尽可能的复用相同标签名元素(例如`input`)，若不希望复用，只需在相同标签名元素上添加一个具有唯一值的 key 属性即可。

> v-if 对比 v-show(display)

首先比较 `visibility:hidden;` 与 `display:none;`

二者共同点：
* 1.都使元素不可见；
* 2.值变化时，都会触发浏览的重绘。
* 3.仍存在dom tree中(与是否占据dom空间不是一个概念)。

二者不同点：`visibility: hidden;`仍然占据dom空间，后面的元素不会覆盖其位置，造成空白区域，即值改变只会重绘不会重排，而`display:none;`不会占据dom空间，后面的元素不会覆盖其位置，即值改变既会重绘又会重排。

其次比较 `v-if` 与 `v-show`
> v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。

而`v-if`是彻底的插入或删除元素，删除后dom tree中不存在(注意与上述第3点不同)，所以我认为有些文章描述的`v-if`是`visibility`实现的，是不对的。

> v-show 不支持 `<template>` 元素，也不支持 v-else。

> 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

> 不推荐同时使用 v-if 和 v-for。当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。

***
## 16. v-for、for...in、for...of
**for...in VS for...of ？**

JS中：
* for...in 以不确定顺序的方式遍历对象或数组的可枚举属性key(包括继承来的属性key)
* for...of 以希望的顺序遍历可迭代对象或数组的数据(属性值，而非key)

VUE的`v-for`中：
数组：二者无差异，均是以希望的顺序遍历数组的数据
对象：均以不确定的顺序遍历对象

***
## 17. 数组操作
vue中，可以