## 浏览器渲染原理

1. HTML代码转化为DOM；
2. CSS代码转化为CSSOM（CSS Object Model）；
3. 两种树结合，生成一课渲染树Render Tree（包含每个节点的视觉信息，可以想象成是个三维的树）；
4. 生成布局（layout），即将渲染树的所有节点进行平面排布（flow）（可以想象成是三维树排布成平面树，若再次触发这种排布，就称为重排或回流）；
5. 将布局绘制（print）在屏幕上（若再次触发这种绘制，就称为重绘）
注：
1. 1-3很快，耗时的是4和5，4和5合起来称为“渲染”
2. 重排一定重绘，重绘不一定重排
3. dom操作很消耗性能的原因：a.涉及JS引擎和渲染引擎跨线程的通信; b.会频繁触发重排和重绘。

## 常见浏览器内核
浏览器内核分为两部分：渲染引擎和JS引擎。一般讲浏览器内核都是指渲染引擎。        

| 浏览器 | 渲染引擎 | JS引擎
|----|---- | ----
| IE -> Edge | Trident -> EdgeHTML | JScript
| FireFox | Gecko | JaegerMonkey
| Safari | Webkit | Nitro
| Chrome | Webkit -> Blink | V8
| Opera | Presto -> Blink | Carakan

`js`加载会阻塞吗？
1. 会阻塞`dom树`的解析（生成dom树）。

`css`加载会阻塞吗？
1. 与`html`加载是并行的；
2. 不会阻塞`dom树`的解析（生成dom树）；
3. 会阻塞`dom树`的渲染（生成渲染树）；
4. 会阻塞后边`js`的执行。

减少白屏，应提高css加载速度：
1. 使用`CDN`；
2. 进行压缩（`webpack`、`gulp`等进行打包，或开启`gzip`压缩）；
3. 合理使用缓存（设置cache-control、expires、e-tag）；
4. 减少请求数（合并资源）。

浏览器如何解析css选择器？   
浏览器会『从右往左』解析CSS选择器。   
从`dom树`和`css树`渲染生成渲染树，实际上是将`css`样式附着到对应的`dom`节点上，而每附着一个样式都要对`dom树`进行遍历。

以这段代码为例：

    .mod-nav h3 span {font-size: 16px;}

对应的`dom树`结构如下：

若从左向右匹配，即从根节点开始沿每个节点分支进行遍历，结果是每个分支都要被遍历一次；
但是从右向左匹配，可以直接剔除很多分支，可以大大提高遍历效率。

DOMContentLoaded 与 load 区别？
* `load`：等待页面所有资源加载完成才会触发，包括css、js、图片等；
* `DOMContentLoaded`：等待dom资源解析完成就会触发，但由于js会阻塞dom的解析，所以要触发时机要具体分析；
* `DOMContentLoaded`总是早于`load`触发。

`async`与`defer`的区别？        
* 有`async`，加载和渲染后边的`html`，将与`js`的加载和执行并行进行，且先加载完成的`async`优先执行，即执行顺序与加载顺序无关。适用于不操作`dom`的`js`文件的加载。
* 有`defer`，加载和渲染后边的`html`，将与`js`的加载并行进行，但`js`的执行要在`html`解析结束且`DOMContentLoaded`触发之前，而且执行顺序与加载顺序一致。


综上所述，我们得出这样的结论：

* 浏览器工作流程：构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制。
* CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。
* 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才继续DOM构建。



参考：
https://juejin.im/post/5e143104e51d45414a4715f7

https://fed.taobao.org/blog/taofed/do71ct/performance-composite/?spm=taofed.blogs.blog-list.10.67bd5ac8fHy0LS

https://zhuanlan.zhihu.com/p/47407398

https://juejin.im/post/5a6547d0f265da3e283a1df7