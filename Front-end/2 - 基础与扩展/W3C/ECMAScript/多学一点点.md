1. `document.querySelector('#app')`与`document.getElementById('app')`有什么区别？
    
        <ul>
            <li>111</li>
            <li>222</li>
            <li>333</li>
        </ul>

        //`document.querySelector('#app')`选出的元素是静态的：
        <script>
            var ul = document.querySelector('ul');
            var list = ul.querySelectorAll('li');
            //又创建了5个新的li，添加在ul列表上。
            for (var i = 0; i < 5; i++) {
                ul.appendChild(document.createElement('li'));
            }
            console.log(list.length)  // 仍然是3
        </script>

        // `document.getElementById('app')`是动态的
        <script>
            var ul = document.getElementsByTagName('ul')[0];
            var list = ul.getElementsByTagName('li');
            //又创建了5个新的li，添加在ul列表上。
            for (var i = 0; i < 5; i++) {
                ul.appendChild(document.createElement('li'));
            }
            console.log(list.length)  // 变成了8
        </script>

    同理可推广到：`document.querySelectorAll`、`document.getElementsByClassName`、`document.getElementsByTagName`

2. `dom`对象与`jQuery`对象互转

        var pDom = document.querySelectorAll('p')
        var $pDom = $('p')
        
        // dom 转 jQuery
        var $pDom1 = $(pDom)

        // jQuery 转 dom，分两种情况
        // 情况一：jQuery 对象只含有一个元素，例如 $('#p')
        var pDom1 = $pDom[0]      // 方法1
        var pDom2 = $pDom.get(0)  // 方法2
        // 情况二：jQuery 对象含有多个元素，例如 $('p')
        var pDom1 = []
        var len = $pDom.length
        for(var i = 0; i < len; i++) {
            pDom1.push($pDom[i])
        }

3. 实现动画效果

        // CSS
        .box {
            position: relative; // relative、absolute、fixed之一
            animation: mymove 5s infinite;
        }
        @keyframes {
            from {
                left: 0;
            }
            to {
                left: 200px;
            }
        }

        // js —— 定时器
        let box = document.querySelector('.box')
        let flag = true
        let left = 0
        setInterval(() => {
            left === 0 ? flag = true : (left === 100 ? flag = false : '')
            flag ? box.style.left = `${left++}px` : box.style.left = `${left--}px`
        }, 1000 / 60)

        // js —— requestAnimationFrame
        let box = document.getElementById(".box");
        let flag = true;
        let left = 0;
        function render() {
            left == 0 ? flag = true : left == 100 ? flag = false : '';
            flag ? box.style.left = ` ${left++}px` : box.style.left = ` ${left--}px`;
        }
        let requestAnimFrame = (function(){     //兼容性处理
            return  window.requestAnimationFrame       ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame    ||
                    function(callback){
                        window.setTimeout(callback, 1000 / 60);
                    };
        })();
        (function animloop() {
            render();
            requestAnimFrame(animloop);
        })();

    两种js实现方案对比：        
    渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是DOM视图更新的最小间隔。由于主流的屏幕刷新率都在60hz，因此渲染一帧的时间就必须控制在16.7ms内才能保证不掉帧。也就是说每一次渲染都要在 16.7ms 内页面才够流畅不会有卡顿感。这段时间内浏览器需要完成如下事情：

    * js执行：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等
    * 样式计算
    * 重排和重绘

    一个帧内要做这么多事情，如果js执行时间过长超过16.7ms，就会丢掉一次帧的绘制，出现卡顿现象。一般一个帧内的多次DOM改动会被合并渲染。

    window.requestAnimationFrame用于在下一个渲染帧之前执行一个回调函数。可以用来做逐帧动画，这会使你的动画函数先于浏览器重绘动作。通常来说，被调用的频率就是60hz。

4. 实现一个“沉睡”函数

        function sleep(time) {
            return new Promise((resolve) => {
                setTimeout(resolve, time)
            })
        }
5. 数组去重

        [...new Set([1,1,3,4,2,2])]  或 Array.from(new Set([1,1,3,4,2,2]))

6. 如何避免重定向？