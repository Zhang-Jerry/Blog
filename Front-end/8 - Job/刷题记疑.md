## 第二期阿里前端面试

1. JS 数据类型与栈、堆的关系，与垃圾回收的关系

  基本数据类型(Undefined、Null、Number、String、Boolean、Symbol)，存储在栈中，分配时就确定了大小或者大小上限，存储数据不再使用时，内存会自动释放。

  引用数据类型(Object、Array、Function等)，存储在堆中，指针(堆内存地址)存储在栈中，内存大小在运行时动态分配，无法自动释放，需手动或借助 JS 的垃圾回收机制。


2. 正则

    // 将浮点数点左边的数每三位添加一个逗号
    number.replace(/(?!^)(?=(\d{3})+\.)/g, ",")   // exp1(?=exp2)：查找 exp2 前面的 exp1

    // 匹配 16 进制颜色值
    /^#[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/g

    // 匹配日期，如 yyyy-mm-dd
    /^[0-9]{4}-(0[1-9]|1[0-2])-(0[0-9]|[12][0-9]|3[01])$/g

    // 匹配 qq 号
    /^[1-9][0-9]{4, 10}$/g

    // 手机号码
    /^1[34578]\d{9}$/g

3. 继承的实现方式、创建对象的方式，其中寄生组合式继承的实现

4. 应避免使用 eval() 

  * 性能低(执行两次，第1次将字符串解析成js代码，第2次执行js代码)

  * 不安全(易被利用做 xss 攻击)

  * 实际上，script 标签， settimeout， setinterval，new Function 等间接调用了eval函数

5. 闭包应用场景

  * 封装私有变量
  * setTimeout 或 addEventListener 传参
  * 防抖 或 截流

    // 防抖 (连续触发时，忽略中间的触发，只执行最后一次触发)
    function debounce(fn, delay) {
      let timer = null
      return function(args) {
        if (timer) {
          timer = null
          clearTimeout(timer)
        }
        timer = setTimeout(() => {
          fn(args)
        }, delay)
      }
    }

    // 截流 (连续触发时，每隔一段时间才会真正触发，其它触发会被忽略)
    function throttle(fn, delay) {
      let timer = null
      return function(args) {
        if (timer) return
        timer = setTimerout(() => {
          timer = null
          clearTimeout(timer)
          fn(args)
        }, delay)
      }
    }

6. new

    function myNew(Fn, ...args) {
      const obj = {}
      Object.setPrototypeOf(obj, Fn.prototype)
      const rtn = Fn.apply(obj, arg)
      return rtn instance Object ? rtn : obj
    }

