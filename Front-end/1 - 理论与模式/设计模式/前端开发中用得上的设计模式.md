https://cloud.tencent.com/developer/article/1627336
- [什么是设计模式](#什么是设计模式)
- [分类](#分类)
- [一、结构型模式](#一结构型模式)
  - [外观模式](#外观模式)
  - [代理模式](#代理模式)
- [二、创建型模式](#二创建型模式)
  - [工厂模式](#工厂模式)
  - [单例模式](#单例模式)
  - [单例模式](#单例模式-1)
  - [工厂模式](#工厂模式-1)
  - [策略模式](#策略模式)
  - [代理模式](#代理模式-1)
  - [观察者模式](#观察者模式)
  - [模块模式](#模块模式)
  - [构造函数模式](#构造函数模式)
  - [混合模式](#混合模式)


# 什么是设计模式

> 对软件设计开发过程中反复出现的某类问题的通用解决方案。是指导思想和方法论，不是特定的代码。


# 分类

1. **结构型模式**：通过识别系统中组件间的简单关系来简化系统的设计。
2. **创建型模式**：处理对象的创建，根据实际情况使用合适的方式创建对象。
3. **行为型模式**：用于识别对象之间常见的交互模式并加以实现。


# 一、结构型模式

## 外观模式

**是什么**：通过为子系统中的一组接口提供统一的高层接口，是子系统更容易使用。简而言之外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API。

**做什么**：比如JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。

**怎么做**：以封装一个DOM事件绑定/解绑方法为例。

        function addEvent(element, event, handler) {
            if (element.addEventListener) {
                element.addEventListener(event, handler, false)
            } else if (element.attachEvent) {
                element.attachEvent('on' + event, handler)
            } else {
                element['on' + event] = handler
            }
        }

        function removeEvent(element, event, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(event, handler, false)
            } else if (element.attachEvent) {
                element.detachEvent('on' + event, handler)
            } else {
                element['on' + event] = null
            }
        }


## 代理模式

**是什么**：想要访问某个对象，但是调用该对象的代价比较高(耗时、流程复杂等)，可以封装一个代理对象，将对目标对象的调用封装在代理对象中，并对外暴露一个与目标对象相同(或更简单)的调用接口。

**做什么**：提高调用性能、简化调用复杂度

**怎么做**：


# 二、创建型模式

## 工厂模式

**是什么**：可以看成是一个制造其他对象的对象，制造出的对象也会随着传入工厂对象参数的不同而有所区别。

**做什么**：提供一种集中化、统一化的方式创建对象，避免了分散创建对象导致的代码重复、灵活性差的问题。

**怎么做**：以构造一个简单的汽车工厂来生产汽车为例

        // 汽车构造函数
        function SuzukiCar(color) {
            this.color = color;
            this.brand = 'Suzuki';
            ...other1...
        }

        // 汽车构造函数
        function HondaCar(color) {
            this.color = color;
            this.brand = 'Honda';
            ...other2...
        }

        // 汽车构造函数
        function BMWCar(color) {
            this.color = color;
            this.brand = 'BMW';
            ...other3...
        }

        // 汽车品牌枚举
        const BRANDS = {
            suzuki: 1,
            honda: 2,
            bmw: 3
        }

        /**
        * 汽车工厂
        */
        function CarFactory() {
            this.create = function (brand, color) {
                switch (brand) {
                case BRANDS.suzuki:
                    return new SuzukiCar(color);
                case BRANDS.honda:
                    return new HondaCar(color);
                case BRANDS.bmw:
                    return new BMWCar(color);
                default:
                    break;
                }
            }
        }

        /**
        * 使用
        */
        const carFactory = new CarFactory();

        carFactory.create(BRANDS.suzuki, 'brown')
        carFactory.create(BRANDS.honda, 'grey')
        carFactory.create(BRANDS.bmw, 'red')


## 单例模式

**是什么**：顾名思义，单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。

**做什么**：全局提示弹窗(全局唯一)、唯一登录浮窗

**怎么做**：














## 单例模式

## 工厂模式

## 策略模式

实现函数`Validator`用于验证权限(其中一个或多个): 1.必须是数组，2.长度必须大于3，3. 元素必须为数字

        // 定义策略
        var strategies = {
            checkType: function(data) {
                return Array.isArray(data)
            },
            checkLength: function(data) {
                return data.length > 3
            },
            checkNumber: function(data) {
                return data.every(function(item) {
                    return !isNaN(item)
                })
            }
        }

        // 定义`Validator`
        var Validator = function() {
            this.cache = []
            // 添加策略
            this.add = function(data, strategyName) {
                this.cache.push(function() {
                    return strategies[strategyName](data)
                })
            }
            // 验证策略
            this.check = function() {
                let len = this.cache.length
                for (let i = 0; i < len; i++) {
                    let valiFn = this.cache[i]
                    var isCheck = valiFn()
                    if (!isCheck) {
                        return false
                    }
                }
                return true
            }
        }

使用1：input1需验证：1.必须是数组

        var checkInput1 = function(data) {
            var validator = new Validator()
            validator.add(data, 'checkType')
            console.log(validator.check())
        }
        checkInput1(['aa', 'cc'])   // true

使用2：input1需验证：1.必须是数组，2.长度必须大于3，3. 元素必须为数字

        var checkInput1 = function(data) {
            var validator = new Validator()
            validator.add(data, 'checkType')
            validator.add(data, 'checkLength')
            validator.add(data, 'checkNumber')
            console.log(validator.check())
        }
        checkInput1([1,2,3,4,5])    // true

实践场景：债券计算器表单输入

## 代理模式

## 观察者模式

## 模块模式

## 构造函数模式

## 混合模式